'''
        Author: Mahendra Maiti
'''
import random
import argparse

class euler:

    def __init__(self,in_file_name,out_file_name):
        self.G={}
        self.sources={}
        self.file_name=in_file_name
        self.output_file=out_file_name
        self.__parse_input()
        self.node_list=[]
        self.final_string=""
        self.assembled_list=[]
        self.assembled_string=""
        
        

    def __parse_input(self):
        '''
            Read from edge list generated by kMerDeBruin.R
        '''
        lines=[line.rstrip('\n') for line in open(self.file_name)]
        for line in lines:
            nodes=line.split('\t')
            if nodes[0] not in self.G:
                self.G[nodes[0]]=[]
                self.sources[nodes[0]]=1
            if nodes[1] not in self.G:
                self.G[nodes[1]]=[]
            self.G[nodes[0]].append(nodes[1])

    def walk(self,node):
        '''
                Recursive version of eulerian walk
        '''
        while len(self.G[node])>0:
            destination=self.G[node].pop()
            self.walk(destination)
        self.node_list.append(node)


    def walk_iter(self,node):
        '''
            Iterative version of eulerian walk
        '''
        stack=[]
        stack.append(node)

        while len(stack)> 0:
            curr_node=stack[-1]
            if len(self.G[curr_node])==0:
                if curr_node in self.sources:
                    self.sources.pop(curr_node)
                self.node_list.append(curr_node)
                stack.pop()
                continue
            if len(self.G[curr_node])>0:
                destination=self.G[curr_node].pop() 
                stack.append(destination)


    def stitch_substrings(self,substrings):
        '''
            Merge generated substrings from Eulerian Walks on disconnected components
        '''
        s = substrings[0]
        del substrings[0]

        while len(substrings) > 0: 
            best_match = [0, 0, "start"] 
            index_of_sub = 0
            for o in substrings:
                for i in range(len(o) - 1):
                    start = o[:-(i + 1)]
                    end = o[(i + 1):]
                    if s.endswith(start): 
                        if best_match[1] < len(start):
                            best_match = [index_of_sub, len(start), "start"]

                    if s.startswith(end):
                        if best_match[1] < len(end):
                            best_match = [index_of_sub, len(end), "end"]

                index_of_sub += 1
            
            if best_match[2] == "start":
                s += substrings[best_match[0]][best_match[1]:]
                del substrings[best_match[0]]
            else:
                s = substrings[best_match[0]][:-best_match[1]] + s
                del substrings[best_match[0]]

        return s



    def reconstruct(self):
        '''
            Reconstruct the original input sequence by performing random walks and subsequently merging generated substrings
        '''
        while len(self.sources.keys()) >0:
            next_source=next(iter(self.sources))
            self.walk_iter(next_source)
            self.node_list=self.node_list[::-1]
            self.final_string=E.node_list[0]+''.join(map(lambda x: x[-1],E.node_list[1:]))
            self.assembled_list.append(self.final_string)
            self.final_string=""
            self.node_list=[]

        self.assembled_string=self.stitch_substrings(self.assembled_list)       #final assembled string



    def dump_output(self):
        '''
                Write assembled string to file
        '''
        fw=open(self.output_file,'w')
        fw.write(self.assembled_string)
        fw.close()

  
def make_arg_parser():
    parser = argparse.ArgumentParser(prog='reconstruct2.py', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    parser.add_argument("-i","--input",
                        default=argparse.SUPPRESS,
                        required=True,
                        help="Path to input edge file")    


    parser.add_argument("-o","--output",
                        default=argparse.SUPPRESS,
                        required=True,
                        help="Path to output file")    
    return parser
    

if __name__ == '__main__':
    parser = make_arg_parser()
    args = parser.parse_args()
    E=euler(args.input,args.output)
    #print(E.G)
    E.reconstruct()
    #print(E.final_string)
    E.dump_output()

